from .base_generator import *
from .case_utils import *
from .definitions import *

import logging
import re
import string
import textwrap


_LOG = logging.getLogger(__name__)

_JAVA_PACKAGE = "org.rocstreaming.roctoolkit"

_JAVA_TYPE_MAP = {
    "unsigned int": "int",
    "int": "int",
    "unsigned long": "long",
    "long": "long",
    "unsigned long long": "long",
    "long long": "long",
    "char": "String",
}

_JAVA_PSEUDO_ENUMS = [
    "roc_packet_encoding",
]

_JAVA_TYPE_OVERRIDE = {
    "packetLength": "Duration",
    "targetLatency": "Duration",
    "latencyTolerance": "Duration",
    "noPlaybackTimeout": "Duration",
    "choppyPlaybackTimeout": "Duration",
    "reuseAddress": "boolean",
}

_JAVA_NAME_OVERRIDE = {
    "roc_context": "RocContext",
    "roc_sender": "RocSender",
    "roc_receiver": "RocReceiver",
    "roc_context_config": "RocContextConfig",
    "roc_sender_config": "RocSenderConfig",
    "roc_receiver_config": "RocReceiverConfig",
}

_JAVA_COMMENT_OVERRIDE = {
    "RocContextConfig": """
        /**
         * Context configuration.
         * <p>
         * RocContextConfig object can be instantiated with {@link RocContextConfig#builder()}.
         *
         * @see RocContext
         */
    """,
    "RocSenderConfig": """
        /**
         * Sender configuration.
         * <p>
         * RocSenderConfig object can be instantiated with {@link RocSenderConfig#builder()}.
         *
         * @see RocSender
         */
    """,
    "RocReceiverConfig": """
        /**
         * Receiver configuration.
         * <p>
         * RocReceiverConfig object can be instantiated with {@link RocReceiverConfig#builder()}.
         *
         * @see RocReceiver
         */
    """,
    "InterfaceConfig": """
        /**
         * Interface configuration.
         * <p>
         * Sender and receiver can have multiple slots ( {@link Slot} ), and each slot
         * can be bound or connected to multiple interfaces ( {@link Interface} ).
         * <p>
         * Each such interface has its own configuration, defined by this class.
         * <p>
         * See {@link RocSender#configure()}, {@link RocReceiver#configure()}.
         */
    """,
}


class JavaGenerator(BaseGenerator):

    def __init__(self, base_path: str, api_root: ApiRoot):
        super().__init__(api_root)

        self._base_path = base_path
        self._api_root = api_root

        self._autogen_comment = [
            f"Code generated by bindgen.py from roc-streaming/bindgen",
            f"roc-toolkit git tag: {api_root.git_info.tag}, commit: {api_root.git_info.commit}",
        ]

    def generate_enum(self, enum_definition: EnumDefinition):
        if enum_definition.name in _JAVA_PSEUDO_ENUMS:
            self.generate_pseudo_enum(enum_definition)
        else:
            self.generate_java_enum(enum_definition)

    def generate_java_enum(self, enum_definition: EnumDefinition):
        java_name = self._get_java_enum_name(enum_definition.name)
        java_comment = self._get_java_comment(java_name, enum_definition.doc)

        out_path = self._get_java_path(java_name)
        _LOG.debug(f"Writing {out_path}")
        out_file = open(out_path, "w")

        for line in self._autogen_comment:
            out_file.write(f"// {line}\n")
        out_file.write(f"\n")

        out_file.write(f"package {_JAVA_PACKAGE};\n\n")

        out_file.write(java_comment)
        out_file.write(f"public enum {java_name} {{\n")

        for enum_value in enum_definition.values:
            java_enum_value = self._get_java_enum_value_name(enum_definition.name, enum_value.name)
            out_file.write(f"\n")
            out_file.write(self._format_javadoc(enum_value.doc, 4))
            out_file.write(f"    {java_enum_value}({enum_value.value}),\n")

        out_file.write(f"    ;\n\n")

        out_file.write(f"    final int value;\n\n")

        out_file.write(f"    {java_name}(int value) {{\n")
        out_file.write(f"        this.value = value;\n")
        out_file.write(f"    }}\n")

        out_file.write(f"}}\n")
        out_file.close()

    def generate_pseudo_enum(self, enum_definition: EnumDefinition):
        java_name = self._get_java_enum_name(enum_definition.name)
        java_comment = self._get_java_comment(java_name, enum_definition.doc)

        out_path = self._get_java_path(java_name)
        _LOG.debug(f"Writing {out_path}")
        out_file = open(out_path, "w")

        for line in self._autogen_comment:
            out_file.write(f"// {line}\n")
        out_file.write(f"\n")

        out_file.write(f"package {_JAVA_PACKAGE};\n\n")

        out_file.write(f"import lombok.EqualsAndHashCode;\n\n")

        out_file.write(java_comment)
        out_file.write(f"@EqualsAndHashCode\n")
        out_file.write(f"public class {java_name} {{\n")

        for enum_value in enum_definition.values:
            java_enum_value = self._get_java_enum_value_name(enum_definition.name, enum_value.name)
            out_file.write(f"\n")
            out_file.write(self._format_javadoc(enum_value.doc, 4))
            out_file.write(
                f"    static {java_name} {java_enum_value} = new {java_name}({enum_value.value});\n")

        out_file.write(f"\n")
        out_file.write(f"    final int value;\n\n")

        out_file.write(f"    public {java_name}(int value) {{\n")
        out_file.write(f"        this.value = value;\n")
        out_file.write(f"    }}\n\n")

        out_file.write(f"    public int getValue() {{\n")
        out_file.write(f"        return value;\n")
        out_file.write(f"    }}\n\n")

        out_file.write(f"    @Override\n")
        out_file.write(f"    public String toString() {{\n")
        out_file.write(f"        return \"{java_name}(\" + value + \")\";\n")
        out_file.write(f"    }}\n\n")

        out_file.write(f"}}\n")
        out_file.close()

    def generate_struct(self, struct_definition: StructDefinition):
        java_name = self._get_java_struct_name(struct_definition.name)
        java_comment = self._get_java_comment(java_name, struct_definition.doc)

        out_path = self._get_java_path(java_name)
        _LOG.debug(f"Writing {out_path}")
        out_file = open(out_path, "w")

        for line in self._autogen_comment:
            out_file.write(f"// {line}\n")
        out_file.write(f"\n")

        out_file.write(f"package {_JAVA_PACKAGE};\n\n")

        out_file.write(f"import java.time.Duration;\n")
        out_file.write(f"import lombok.*;\n\n")

        out_file.write(java_comment)
        out_file.write(f"@Getter\n")
        out_file.write(f"@Builder(builderClassName = \"Builder\", toBuilder = true)\n")
        out_file.write(f"@ToString\n")
        out_file.write(f"@EqualsAndHashCode\n")
        out_file.write(f"public class {java_name} {{\n")

        for f in struct_definition.fields:
            out_file.write(f"\n")
            out_file.write(self._format_javadoc(f.doc, 4))
            field_type = self._get_java_struct_field_type(f)
            field_name = self._get_java_struct_field_name(f.name)
            out_file.write(f"    private {field_type} {field_name};\n")

        out_file.write(f"\n")
        out_file.write(f"    /**\n")
        out_file.write(f"     * Construct builder for {{@link {java_name}}}.\n")
        out_file.write(f"     */\n")
        out_file.write(f"    public static {java_name}.Builder builder() {{\n")
        out_file.write(f"        return new {java_name}Validator();\n")
        out_file.write(f"    }}\n")

        out_file.write(f"}}\n")
        out_file.close()

    def generate_class(self, class_definition: ClassDefinition):
        java_name = self._get_java_struct_name(class_definition.name)
        java_comment = self._get_java_comment(java_name, class_definition.doc)

        out_path = self._get_java_path(java_name, dummy=True)
        _LOG.debug(f"Writing {out_path}")
        out_file = open(out_path, "w")

        for line in self._autogen_comment:
            out_file.write(f"// {line}\n")
        out_file.write(f"\n")

        out_file.write(f"package {_JAVA_PACKAGE};\n\n")

        out_file.write(java_comment)
        out_file.write(f"public class Roc{java_name} {{\n")

        for method in class_definition.methods:
            java_method_name = to_camel_case(method.name.removeprefix(class_definition.name + "_"))
            java_method_comment = self._format_javadoc(method.doc, 4)
            if java_method_name in ["open", "close"]:
                continue
            out_file.write(f"\n")
            out_file.write(java_method_comment)
            out_file.write(f"    public void {java_method_name}() {{\n")
            out_file.write(f"        // TODO: implement; fix signature\n")
            out_file.write(f"    }}\n")

        out_file.write(f"}}\n")
        out_file.close()

    def _get_java_path(self, java_name, dummy=False):
        if dummy:
            java_name += "_DUMMY"
        return (self._base_path + "/src/main/java/"
                + _JAVA_PACKAGE.replace(".", "/") + "/" + java_name + ".java")

    def _get_java_comment(self, java_name, doc):
        if java_name in _JAVA_COMMENT_OVERRIDE:
            return textwrap.dedent(_JAVA_COMMENT_OVERRIDE[java_name]).lstrip()
        else:
            return self._format_javadoc(doc, 0)

    def _get_java_enum_name(self, roc_name):
        if roc_name in _JAVA_NAME_OVERRIDE:
            return _JAVA_NAME_OVERRIDE[roc_name]
        return to_pascal_case(roc_name.removeprefix('roc_'))

    def _get_java_enum_value_name(self, roc_enum_name, roc_enum_value_name):
        prefix = self._api_root.enum_prefixes.get(roc_enum_name)
        return roc_enum_value_name.removeprefix(prefix)

    def _get_java_struct_name(self, roc_name):
        if roc_name in _JAVA_NAME_OVERRIDE:
            return _JAVA_NAME_OVERRIDE[roc_name]
        return to_pascal_case(roc_name.removeprefix('roc_'))

    def _get_java_struct_field_type(self, field):
        java_field_name = to_camel_case(field.name)
        if java_field_name in _JAVA_TYPE_OVERRIDE:
            return _JAVA_TYPE_OVERRIDE[java_field_name]
        elif field.type.startswith('roc_'):
            return self._get_java_class_name(field.type)
        elif field.type in _JAVA_TYPE_MAP:
            return _JAVA_TYPE_MAP[field.type]
        else:
            return field.type

    def _get_java_struct_field_name(self, field_name):
        return to_camel_case(field_name)

    def _get_java_class_name(self, roc_name):
        if roc_name in _JAVA_NAME_OVERRIDE:
            return _JAVA_NAME_OVERRIDE[roc_name]
        return to_pascal_case(roc_name.removeprefix('roc_'))

    def _get_java_class_method_name(self, roc_method_name):
        return to_camel_case(roc_method_name)

    def _format_javadoc(self, doc: DocComment, indent_size: int):
        indent = " " * indent_size
        indent_line = indent + " * "

        doc_string = indent + "/**\n"

        for i, block in enumerate(doc.blocks):
            if i != 0:
                doc_string += indent + " * <p>\n"
            doc_string += self._wrap_text(self._doc_block_to_string(block),
                                          indent_line)

        doc_string += indent + " */\n"
        return doc_string

    def _doc_block_to_string(self, block: DocBlock):
        result = []
        for item in block.items:
            t = item.type
            if t == "text":
                result.append(item.text)
            elif t == "bold":
                result.append(f'<b>{item.text}</b>')
            elif t == "emphasis":
                result.append(f'<em>{item.text}</em>')
            elif t == "ref" or t == "code":
                result.append(self._doc_ref_to_string(item.text))
            elif t == "see":
                result.append("@see")
            elif t == "list":
                ul = "\n<ul>\n"
                for li in item.child_blocks:
                    ul += self._wrap_text(self._doc_block_to_string(li),
                                          "  <li>",
                                          "      ",
                                          "</li>\n")
                ul += "</ul>\n"
                result.append(ul)
            else:
                _LOG.warning(
                    f"Unknown doc item type = {t}, consider adding it to _doc_block_to_string")
        return ' '.join(result).replace(" ,", ",").replace(" .", ".")

    def _doc_ref_to_string(self, ref_value: str):
        """
        :param ref_value: enum_value or enum_type, e.g. roc_endpoint or ROC_INTERFACE_AUDIO_SOURCE
        :return: java link javadoc or None if not found
        """
        ref_link = None
        ref_code = ref_value

        if ref_value in self._api_root.doc_refs:
            ref = self._api_root.doc_refs[ref_value]

            if ref.type == "enum":
                ref_link = self._get_java_enum_name(ref.name)
            elif ref.type == "enum_value":
                enum_name = self._get_java_enum_name(ref.enum_name)
                value_name = self._get_java_enum_value_name(ref.enum_name, ref.enum_value_name)
                ref_link = f"{enum_name}#{value_name}"
            elif ref.type == "struct":
                ref_link = self._get_java_struct_name(ref.name)
            elif ref.type == "struct_field":
                ref_code = self._get_java_struct_field_name(ref.name)
            elif ref.type == "class":
                ref_link = self._get_java_class_name(ref.name)
            elif ref.type == "class_method" and ref.class_method_name == "open":
                class_name = self._get_java_class_name(ref.class_name)
                ref_link = f"{class_name}()"
            elif ref.type == "class_method":
                class_name = self._get_java_class_name(ref.class_name)
                method_name = self._get_java_class_method_name(ref.class_method_name)
                ref_link = f"{class_name}#{method_name}()"
            elif ref.type == "typedef":
                ref_link = self._get_java_class_name(ref.name)
            else:
                _LOG.warning(
                    f"Unknown doc ref type = {ref.type}, consider adding it to _doc_ref_to_string")
                ref_code = self._get_java_class_name(ref.name)

        if ref_link:
            return "{@link " + ref_link + "}"
        else:
            return "{@code " + ref_code + "}"

    def _wrap_text(self, text, indent, initial_indent=None, suffix=None):
        if not initial_indent:
            initial_indent = indent

        if suffix:
            text += suffix

        # hack: mask spaces to prevent textwrap from breaking inline tags
        # (like {@link ...})
        text = re.sub(r'(\{@[a-z]+)(\s+)(\S+)(\})',
                      r'\1_\3\4',
                      text, flags=re.MULTILINE)

        # iterate segments
        result = ''
        while text:
            m = re.match(r'^(.*)([\n\s]*<ul>.*?</ul>[\n\s]*)(.*)$', text, re.DOTALL)
            if m:
                # next segment of regular text (should be wrapped)
                text_segment = m.group(1)
                # next segment of html list (should be kept as is)
                list_segment = m.group(2)
                text = m.group(3)
            else:
                text_segment = text
                list_segment = ''
                text = ''

            if text_segment:
                lines = textwrap.wrap(text_segment,
                                      width=100-len(indent),
                                      break_on_hyphens=False,
                                      break_long_words=False,
                                      initial_indent=indent,
                                      subsequent_indent=initial_indent)
                for line in lines:
                    result += line + "\n"

            if list_segment:
                lines = list_segment.splitlines()
                for line in lines:
                    result += indent + line + "\n"

        # unhack: restore spaces
        result = re.sub(r'(\{@[a-z]+)(_)(\S+)(\})',
                        r'\1 \3\4',
                        result)

        return result
